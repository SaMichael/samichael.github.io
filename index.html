<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>SaMicahel&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="技术成长、分享">
<meta property="og:type" content="website">
<meta property="og:title" content="SaMicahel's blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="SaMicahel's blog">
<meta property="og:description" content="技术成长、分享">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="SaMicahel's blog">
<meta name="twitter:description" content="技术成长、分享">
  
    <link rel="alternative" href="/atom.xml" title="SaMicahel&#39;s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
      <link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css" type="text/css">
  
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  
    
    
  
  
      <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  
  <script>
      var yiliaConfig = {
          fancybox: true,
          animate: true,
          isHome: true,
          isPost: false,
          isArchive: false,
          isTag: false,
          isCategory: false,
          open_in_new: false
      }
  </script>
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            
            <img lazy-src="/img/avatar.jpeg" class="js-avatar">
            
        </a>

        <hgroup>
          <h1 class="header-author"><a href="/">SaMichael</a></h1>
        </hgroup>

        
                


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/tags/">标签云</a></li>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <li id="Email"><a class="Email" target="_blank" href="mailto:njuluwenbin@163.com" title="Email"></a></li>
                            
                                <li id="GitHub"><a class="GitHub" target="_blank" href="https://github.com/SaMichael" title="GitHub"></a></li>
                            
                                <li id="RSS"><a class="RSS" target="_blank" href="/atom.xml" title="RSS"></a></li>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <a href="/tags/cpu使用率/" style="font-size: 10px;">cpu使用率</a> <a href="/tags/hessian/" style="font-size: 10px;">hessian</a> <a href="/tags/pigeon/" style="font-size: 10px;">pigeon</a> <a href="/tags/博客/" style="font-size: 10px;">博客</a>
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="https://hexo.io">Hexo</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="https://pages.github.com/">GitHub</a>
                    
                      <a target="_blank" class="main-nav-link switch-friends-link" href="http://moxfive.xyz/">MOxFIVE</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">专注于前端</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">SaMichael</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                
                    <img lazy-src="/img/avatar.jpeg" class="js-avatar">
                
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">SaMichael</a></h1>
            </hgroup>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <li id="Email"><a class="Email" target="_blank" href="mailto:njuluwenbin@163.com" title="Email"></a></li>
                            
                                <li id="GitHub"><a class="GitHub" target="_blank" href="https://github.com/SaMichael" title="GitHub"></a></li>
                            
                                <li id="RSS"><a class="RSS" target="_blank" href="/atom.xml" title="RSS"></a></li>
                            
                        </ul>
            </nav>
        </header>                
    </div>
</nav>
      <div class="body-wrap">
  
    <article id="post-pigeon学习" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/02/03/pigeon学习/" class="article-date">
      <time datetime="2016-02-03T10:04:33.000Z" itemprop="datePublished">2016-02-03</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/02/03/pigeon学习/">pigeon学习</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="pigeon_u4E2D_u7528_u5230_u7684_u6280_u672F"><a href="#pigeon_u4E2D_u7528_u5230_u7684_u6280_u672F" class="headerlink" title="pigeon中用到的技术"></a>pigeon中用到的技术</h1><h2 id="ClassLoader"><a href="#ClassLoader" class="headerlink" title="ClassLoader"></a>ClassLoader</h2><p>java应用环境中不同的class分别由不同的ClassLoader负责加载。<br>一个jvm中默认的classloader有Bootstrap ClassLoader、Extension ClassLoader、App ClassLoader，分别各司其职：</p>
<blockquote>
<ul>
<li>Bootstrap ClassLoader:负责加载java基础类，主要是 %JRE_HOME/lib/ 目录下的rt.jar、resources.jar、charsets.jar和class等</li>
<li>Extension ClassLoader:负责加载java扩展类，主要是 %JRE_HOME/lib/ext 目录下的jar和class</li>
<li>App ClassLoader:负责加载当前java应用的classpath中的所有类。</li>
</ul>
</blockquote>
<p>采用了双亲委派模型，还有个重要的概念，线程的ContextClassLoader。</p>
<blockquote>
<p>具体资料参考以下：</p>
<ul>
<li><a href="http://blog.chinaunix.net/uid-21227800-id-65879.html" target="_blank" rel="external">《ClassLoader的几个念、类和对象的解释》</a></li>
<li>《深入理解java虚拟机》</li>
</ul>
</blockquote>
<h2 id="Class-forName_28_29"><a href="#Class-forName_28_29" class="headerlink" title="Class.forName()"></a>Class.forName()</h2><blockquote>
<p><a href="http://blog.csdn.net/fengyuzhengfan/article/details/38086743?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="external">《Class.forName()作用与总结》</a></p>
</blockquote>
<h2 id="jdk_u52A8_u6001_u4EE3_u7406"><a href="#jdk_u52A8_u6001_u4EE3_u7406" class="headerlink" title="jdk动态代理"></a>jdk动态代理</h2><p>代理模式上，基本上有Subject角色，RealSubject角色，Proxy角色。其中：Subject角色负责定义RealSubject和Proxy角色应该实现的接口；RealSubject角色用来真正完成业务服务功能；Proxy角色负责将自身的Request请求，调用realsubject 对应的request功能来实现业务功能，自己不真正做业务。</p>
<p><img src="http://i13.tietuku.com/350a4520859515e9.png" alt="静态代理类图"></p>
<p>上面的这幅代理结构图是典型的静态的代理模式：</p>
<p><strong>当在代码阶段规定这种代理关系，Proxy类通过编译器编译成class文件，当系统运行时，此class已经存在了。这种静态的代理模式固然在访问无法访问的资源，增强现有的接口业务功能方面有很大的优点，但是大量使用这种静态代理，会使我们系统内的类的规模增大，并且不易维护；并且由于Proxy和RealSubject的功能 本质上是相同的，Proxy只是起到了中介的作用，这种代理在系统中的存在，导致系统结构比较臃肿和松散。</strong></p>
<p>为了解决这个问题，就有了动态地创建Proxy的想法：在运行状态中，需要代理的地方，根据Subject 和RealSubject，动态地创建一个Proxy，用完之后，就会销毁，这样就可以避免了Proxy 角色的class在系统中冗杂的问题了。</p>
<p>如果仍采用上面静态代理的类图，势必会在代理这样公用可抽象的代码里冗余进大量的业务逻辑，因此引入InvocationHandler这个角色。</p>
<h3 id="InvocationHandler"><a href="#InvocationHandler" class="headerlink" title="InvocationHandler"></a>InvocationHandler</h3><p>仔细思考代理模式中的代理Proxy角色。Proxy角色在执行代理业务的时候，无非是在调用真正业务之前或者之后做一些“额外”业务。</p>
<p><img src="http://i13.tietuku.com/ab84091a0e879b92.png" alt=""></p>
<p>有上图可以看出，代理类处理的逻辑很简单：在调用某个方法前及方法后做一些额外的业务。换一种思路就是：在触发（invoke）真实角色的方法之前或者之后做一些额外的业务。那么，为了构造出具有通用性和简单性的代理类，可以将所有的触发真实角色动作交给一个触发的管理器，让这个管理器统一地管理触发。这种管理器就是Invocation Handler。</p>
<p>作用：</p>
<ul>
<li>在静态代理中，代理Proxy中的方法，都指定了调用了特定的realSubject中的对应的方法。在上面的静态代理模式下，Proxy所做的事情，无非是调用在不同的request时，调用触发realSubject对应的方法；更抽象点看，可以把该对应的方法看成对象Method交付给Invocation Handler在一个合适的情况下触发（invoke）</li>
<li>动态代理工作的基本模式就是将自己的方法功能的实现交给 InvocationHandler角色，外界对Proxy角色中的每一个方法的调用，Proxy角色都会交给InvocationHandler来处理，而InvocationHandler则调用具体对象角色的方法。如下图所示：</li>
</ul>
<p><img src="http://i13.tietuku.com/65fceaefd224c2c2.png" alt=""></p>
<p>在这种模式之中：<strong>代理Proxy 和RealSubject应该实现相同的功能</strong>,这一点相当重要。（我这里说的功能，可以理解为某个类的public方法）</p>
<p>在面向对象的编程之中，如果我们想要约定Proxy 和RealSubject可以实现相同的功能，有两种方式：</p>
<ol>
<li>一个比较直观的方式，就是定义一个功能接口，然后让Proxy 和RealSubject来实现这个接口</li>
<li>还有比较隐晦的方式，就是通过继承。因为如果Proxy 继承自RealSubject，这样Proxy则拥有了RealSubject的功能，Proxy还可以通过重写RealSubject中的方法，来实现多态。</li>
</ol>
<p><strong>其中JDK中提供的创建动态代理的机制，是以a 这种思路设计的，而cglib 则是以b思路设计的。</strong></p>
<h3 id="jdk_u52A8_u6001_u4EE3_u7406_u521B_u5EFA_u673A_u5236"><a href="#jdk_u52A8_u6001_u4EE3_u7406_u521B_u5EFA_u673A_u5236" class="headerlink" title="jdk动态代理创建机制"></a>jdk动态代理创建机制</h3><p>比如现在想为RealSubject这个类创建一个动态代理对象，JDK主要会做以下工作：</p>
<ol>
<li>获取 RealSubject上的所有接口列表；</li>
<li>确定要生成的代理类的类名，默认为：com.sun.proxy.$ProxyXXXX；</li>
<li>根据需要实现的接口信息，在代码中动态创建 该Proxy类的字节码；</li>
<li>将对应的字节码转换为对应的class 对象；</li>
<li>创建InvocationHandler 实例handler，用来处理Proxy所有方法调用；</li>
<li>Proxy的class对象 以创建的handler对象为参数，实例化一个proxy对象</li>
</ol>
<blockquote>
<p>下面这篇文章写得非常好，深入浅出讲解了动态代理，强烈推荐：<br><a href="http://blog.csdn.net/luanlouis/article/details/24589193" target="_blank" rel="external">《java动态代理》</a></p>
</blockquote>
<p>JDK通过 java.lang.reflect.Proxy包来支持动态代理，一般情况下，我们使用下面的newProxyInstance方法</p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回一个指定接口的代理类实例，该接口可以将方法调用指派到指定的调用处理程序。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">Object</span> newProxyInstance(ClassLoader loader,<span class="keyword">Class</span>&lt;?&gt;[] interfaces,InvocationHandler h)</span><br></pre></td></tr></table></figure>
<h2 id="SPI_u673A_u5236"><a href="#SPI_u673A_u5236" class="headerlink" title="SPI机制"></a>SPI机制</h2><h3 id="SPI_u7684_u601D_u60F3"><a href="#SPI_u7684_u601D_u60F3" class="headerlink" title="SPI的思想"></a>SPI的思想</h3><p>SPI的全名为Service Provider Interface普通开发人员可能不熟悉，因为这个是针对服务提供厂商与扩展框架功能的开发者的。在java.util.ServiceLoader的文档里有比较详细的介绍。究其思想，其实是和”Callback”差不多。“Callback”的思想是在我们调用API的时候，我们可以自己写一段逻辑代码，传入到API里面，API内部在合适的时候会调用它，从而实现某种程度的“定制”。</p>
<p>我们系统里抽象的各个模块，往往有很多不同的实现方案，比如日志模块的方案，xml解析模块、jdbc模块的方案等。面向的对象的设计里，我们一般推荐模块之间基于接口编程，模块之间不对实现类进行硬编码。一旦代码里涉及具体的实现类，就违反了可拔插的原则，如果需要替换一种实现，就需要修改代码。</p>
<p>为了实现在模块装配的时候能不在程序里动态指明，这就需要一种服务发现机制。java spi就是提供这样的一个机制：为某个接口寻找服务实现的机制。有点类似IOC的思想，就是将装配的控制权移到程序之外，在模块化设计中这个机制尤其重要。</p>
<h3 id="JAVA_SPI_u7684_u7EA6_u5B9A"><a href="#JAVA_SPI_u7684_u7EA6_u5B9A" class="headerlink" title="JAVA SPI的约定"></a>JAVA SPI的约定</h3><p>当服务的提供者，提供了服务接口的一种实现之后，在jar包的META-INF/services/目录里同时创建一个以服务接口命名的文件。该文件里就是实现该服务接口的具体实现类。而当外部程序装配这个模块的时候，就能通过该jar包META-INF/services/里的配置文件找到具体的实现类名，并装载实例化，完成模块的注入。服务厂商实现的jar包你需要放到classpath下。</p>
<p>基于这样一个约定就能很好的找到服务接口的实现类，而不需要再代码里制定。</p>
<p>jdk提供服务实现查找的一个工具类：java.util.ServiceLoader</p>
<blockquote>
<p>SPI扩展阅读：</p>
<ul>
<li><a href="http://blog.csdn.net/comkingfly/article/details/7645245?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="external">《Java spi机制 面向接口的编程》</a></li>
</ul>
</blockquote>
<h3 id="ServiceLoader"><a href="#ServiceLoader" class="headerlink" title="ServiceLoader"></a>ServiceLoader</h3><p>以pigeon为例，在pigeon-remoting项目中，文件名以服务接口类定义，文件路径如下：<br><code>META-INF/services/com.dianping.pigeon.provider.Server</code></p>
<p>文件内容要求很简单，每一行放一个这个接口的一个实现类的类型名称（包含包名和类名），比如:<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">com<span class="class">.dianping</span><span class="class">.pigeon</span><span class="class">.remoting</span><span class="class">.netty</span><span class="class">.provider</span><span class="class">.NettyServer</span></span><br><span class="line">com<span class="class">.dianping</span><span class="class">.pigeon</span><span class="class">.remoting</span><span class="class">.http</span><span class="class">.provider</span><span class="class">.JettyHttpServer</span></span><br></pre></td></tr></table></figure></p>
<p>准备好上述后，我们就可以调用ServiceLoader获取这些服务实例：<br><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServiceLoader&lt;<span class="built_in">Server</span>&gt; servers = ServiceLoader.<span class="keyword">get</span>(<span class="built_in">Server</span>.<span class="keyword">class</span>);</span><br></pre></td></tr></table></figure></p>
<p>这时候ServiceLoader会帮我们去扫描classpath下所有的META-INF/services/目录，如果包含com.dianping.pigeon.provider.Server文件，他初始化配置文件中的服务提供方实例，每一条记录都会对应一个服务实例。</p>
<p><strong>那么问题来了，如果不同的jar包下有相同的文件，ServiceLoader以哪个为准呢？<br>ServiceLoader是通过当前线程的classloader来加载资源文件的，返回的是一个set，但最终以最后一个为准</strong></p>
<h2 id="zookeeper"><a href="#zookeeper" class="headerlink" title="zookeeper"></a>zookeeper</h2><h3 id="u6570_u636E_u6A21_u578B"><a href="#u6570_u636E_u6A21_u578B" class="headerlink" title="数据模型"></a>数据模型</h3><p>zookeeper使用了一个类似文件系统的树结构，数据可以挂在某个节点上，可以对这个节点进行删改，当改动一个节点时，集群中活着的机器都会更新到一致的数据。<br><img src="http://i12.tietuku.com/06811f196ca6d34e.png" alt=""></p>
<ul>
<li>每个节点在zookeeper中叫做znode,并且其有一个唯一的路径标识，如/SERVER2节点的标识就为/APP3/SERVER2；</li>
<li>znode可以有子znode，并且znode里可以存数据，但是EPHEMERAL类型的节点不能有子节点；</li>
<li>znode中的数据可以有多个版本，比如某一个路径下存有多个数据版本，那么查询这个路径下的数据就需要带上版本；</li>
<li>znode可以是临时节点，一旦创建这个znode的客户端与服务器失去联系，这个znode也将自动删除，Zookeeper的客户端和服务器通信采用长连接方式，每个客户端和  服务器通过心跳来保持连接，这个连接状态称为session，如果znode是临时节点，这个session失效，znode也就删除了。</li>
<li>znode的目录名可以自动编号，如App1已经存在，再创建的话，将会自动命名为App2；</li>
<li>znode可以被监控，包括这个目录节点中存储的数据的修改，子节点目录的变化等，一旦变化可以通知设置监控的客户端，这个功能是zookeeper对于应用最重要的特性，通过这个特性可以实现的功能包括配置的集中管理，集群管理，分布式锁等等。</li>
</ul>
<h3 id="u4F7F_u7528_u573A_u666F"><a href="#u4F7F_u7528_u573A_u666F" class="headerlink" title="使用场景"></a>使用场景</h3><h4 id="u914D_u7F6E_u7BA1_u7406"><a href="#u914D_u7F6E_u7BA1_u7406" class="headerlink" title="配置管理"></a>配置管理</h4><p>集中式的配置管理在应用集群中是非常常见的，一般商业公司内部都会实现一套集中的配置管理中心，应对不同的应用集群对于共享各自配置的需求，并且在配置变更时能够通知到集群中的每一个机器。</p>
<p>zookeeper很容易实现这种集中式的配置管理，比如将APP1的所有配置配置到/APP1 znode下，APP1所有机器一启动就对/APP1这个节点进行监控(zk.exist(“/APP1”,true)),并且实现回调方法Watcher，那么在zookeeper上/APP1 znode节点下数据发生变化的时候，每个机器都会收到通知，Watcher方法将会被执行，那么应用再取下数据即可(zk.getData(“/APP1”,false,null));</p>
<p>我们的lion，点评配置管理系统就是基于zookeeper来实现</p>
<h3 id="u96C6_u7FA4_u7BA1_u7406"><a href="#u96C6_u7FA4_u7BA1_u7406" class="headerlink" title="集群管理"></a>集群管理</h3><p>应用集群中，我们常常需要让每一个机器知道集群中（或依赖的其他某一个集群）哪些机器是活着的，并且在集群机器因为宕机，网络断链等原因能够不在人工介入的情况下迅速通知到每一个机器。</p>
<p>Zookeeper同样很容易实现这个功能，比如我在zookeeper服务器端有一个znode叫/APP1SERVERS,那么集群中每一个机器启动的时候都去这个节点下创建一个EPHEMERAL类型的节点，比如server1创建/APP1SERVERS/SERVER1(可以使用ip,保证不重复)，server2创建/APP1SERVERS/SERVER2，然后SERVER1和SERVER2都watch /APP1SERVERS这个父节点，那么也就是这个父节点下数据或者子节点变化都会通知对该节点进行watch的客户端。因为EPHEMERAL类型节点有一个很重要的特性，就是客户端和服务器端连接断掉或者session过期就会使节点消失，那么在某一个机器挂掉或者断链的时候，其对应的节点就会消失，然后集群中所有对/APP1SERVERS进行watch的客户端都会收到通知，然后取得最新列表即可。</p>
<h1 id="u81EA_u5B9A_u4E49Spring_Xml_Bean_u914D_u7F6E"><a href="#u81EA_u5B9A_u4E49Spring_Xml_Bean_u914D_u7F6E" class="headerlink" title="自定义Spring Xml Bean配置"></a>自定义Spring Xml Bean配置</h1><h2 id="PropertyPlaceholderConfigurer"><a href="#PropertyPlaceholderConfigurer" class="headerlink" title="PropertyPlaceholderConfigurer"></a>PropertyPlaceholderConfigurer</h2><h3 id="u57FA_u672C_u4F7F_u7528"><a href="#u57FA_u672C_u4F7F_u7528" class="headerlink" title="基本使用"></a>基本使用</h3><p>Spring中PropertyPlaceholderConfigurer这个类，它是用来解析Java .properties属性文件值，spring bean配置时的属性可以指定文件中的变量来赋值。我们可以通过它来做到在不同环境下配不同的值，动态替换值。</p>
<p>基本使用方法：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"propertyConfigurerForAnalysis"</span> </span><br><span class="line">      <span class="attribute">class</span>=<span class="value">"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"location"</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="title">value</span>&gt;</span>classpath:/spring/include/dbQuery.properties<span class="tag">&lt;/<span class="title">value</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="title">property</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>或者多个Property文件的使用方法：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"propertyConfigurer"</span> <span class="attribute">class</span>=<span class="value">"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"locations"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">list</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--除了上面使用classpath外，还可以使用下述路径--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="title">value</span>&gt;</span>/WEB-INF/config/jdbc/jdbc.properties<span class="tag">&lt;/<span class="title">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="title">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>如果想通过多个PropertyPlaceholderConfigurer来整合分散的.properties文件的话，可以申明多个bean，然后通过bean的order属性决定加载的顺序。如果没有设置就按照加载xml文件时的顺序。</p>
<h3 id="u539F_u7406"><a href="#u539F_u7406" class="headerlink" title="原理"></a>原理</h3><p>PropertyPlaceholderConfigurer的上层有BeanFactoryPostProcessor接口和PlaceholderConfigurerSupport、PropertyResourceConfigurer这两个类。相关定义如下：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">PropertyPlaceholderConfigurer</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">PlaceholderConfigurerSupport</span></span><br><span class="line"></span>public <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">PlaceholderConfigurerSupport</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">PropertyResourceConfigurer</span></span><br><span class="line"></span>             implements <span class="type">BeanNameAware</span>, <span class="type">BeanFactoryAware</span></span><br><span class="line">public <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertyResourceConfigurer</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">PropertiesLoaderSupport</span></span><br><span class="line"></span>             implements <span class="type">BeanFactoryPostProcessor</span>, <span class="type">PriorityOrdered</span></span><br></pre></td></tr></table></figure></p>
<p>spring提供了的一种叫做BeanFactoryPostProcessor的容器扩展机制。它允许我们在容器实例化对象之前，对容器中的BeanDefinition中的信息做一定的修改(比如对某些字段的值进行修改，这就是占位符替换的根本)。于是就需要说下BeanFactoryPostProcessor接口了，以下BeanFactoryPostProcessor的定义：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanFactoryPostProcessor</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在web项目的spring上下文初始化中，spring在实例化bean之前，会先实例化出实现了BeanFactoryPostProcessor接口的bean，并调用postProcessBeanFactory方法，对BeanFactory中的BeanDefinition进行处理。</p>
<p>先看看PropertyResourceConfigurer的postProcessBeanFactory()方法<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      Properties mergedProps = mergeProperties();</span><br><span class="line">      <span class="comment">// Convert the merged properties, if necessary.</span></span><br><span class="line">      convertProperties(mergedProps);</span><br><span class="line">      <span class="comment">// Let the subclass process the properties.</span></span><br><span class="line">      processProperties(beanFactory, mergedProps);</span><br><span class="line">   &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanInitializationException(<span class="string">"Could not load properties"</span>, ex);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个方法整合好Properties，然后以BeanFactory和Properties作为参数调用PropertyPlaceholderConfigurer的processProperties方法。</p>
<p>接着看PropertyPlaceholderConfigurer的processProperties()方法<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">void</span> <span class="title">processProperties</span><span class="params">(ConfigurableListableBeanFactory beanFactoryToProcess, Properties props)</span></span><br><span class="line">      <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">   StringValueResolver valueResolver = <span class="keyword">new</span> PlaceholderResolvingStringValueResolver(props);</span><br><span class="line">   <span class="keyword">this</span>.doProcessProperties(beanFactoryToProcess, valueResolver);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个类就实例化了一个StringValueResolver对象，然后用BeanFactory和StringValueResolver对象调用PlaceholderConfigurerSupport#doProcessProperties()</p>
<p>再看PlaceholderConfigurerSupport的doProcessProperties()方法<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> doProcessProperties(ConfigurableListableBeanFactory beanFactoryToProcess,</span><br><span class="line">      StringValueResolver valueResolver) &#123;</span><br><span class="line">   BeanDefinitionVisitor visitor = <span class="keyword">new</span> BeanDefinitionVisitor(valueResolver);</span><br><span class="line">   <span class="keyword">String</span>[] beanNames = beanFactoryToProcess.getBeanDefinitionNames();</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">String</span> curName : beanNames) &#123;</span><br><span class="line">      <span class="comment">// Check that we're not parsing our own bean definition,</span></span><br><span class="line">      <span class="comment">// to avoid failing on unresolvable placeholders in properties file locations.</span></span><br><span class="line">      <span class="keyword">if</span> (!(curName.equals(<span class="keyword">this</span>.beanName) &amp;&amp; beanFactoryToProcess.equals(<span class="keyword">this</span> .beanFactory ))) &#123;</span><br><span class="line">         BeanDefinition bd = beanFactoryToProcess.getBeanDefinition(curName);</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">            visitor.visitBeanDefinition(bd);</span><br><span class="line">         &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(bd.getResourceDescription(), curName, ex.getMessage());</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// New in Spring 2.5: resolve placeholders in alias target names and aliases as well.</span></span><br><span class="line">   beanFactoryToProcess.resolveAliases(valueResolver);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// New in Spring 3.0: resolve placeholders in embedded values such as annotation attributes.</span></span><br><span class="line">   beanFactoryToProcess.addEmbeddedValueResolver(valueResolver);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个方法就会取出BeanFactory中的BeanDefinition，然后循环处理除了<strong>本身以外的bean</strong>的占位符替换，我们lion的替换和这个代码的处理就差不多。</p>
<p>通过上述流程，我们可以发现定制自己占位符的实现，最重要的其实是BeanFactoryPostProcessor接口，它是一个入口，让我们能拿到用了占位符的属性及其所在的类。Properties主要是占位符的key和value。</p>
<h3 id="u5B9E_u73B0_u601D_u8DEF"><a href="#u5B9E_u73B0_u601D_u8DEF" class="headerlink" title="实现思路"></a>实现思路</h3><p>定制占位符实现有以下几个思路：</p>
<ol>
<li>实现PropertyPlaceholderConfigurer类的mergeProperties()；</li>
<li>实现PropertyPlaceholderConfigurer类的loadProperties()；</li>
<li>实现PropertyPlaceholderConfigurer类的resolvePlaceholder();</li>
</ol>
<p>1和2其实本质都一样，都是通过改动Properties来实现，推荐第一种方法，美团waimai-api加载rabbitmq不同环境的配置用的方法2，个人觉得还是1好些。</p>
<p>点评的${}读的是lion的值，由lion-client这个jar包实现了spring初始化bean占位符的替换，<strong>lion的值修改时动态修改相关bean的属性</strong>（重要功能）。</p>
<p>点评占位符替换用的方法三，resolvePlaceholder()的含义其实是根据占位符内容来获取其属性，那么我们的思路可以是：抛弃Properties，自己实现一个map，存储了lion上所有的变量，从我们维护的map中来获取响应的值。</p>
<p>那么动态修改又是如何实现的呢？上面说了，BeanFactoryPostProcessor可以让我们获取到spring管理的bean，将占位符的key和bean的相关信息存到map里，在zookeeper因为Znode更改通知到时，从map里获取到该key，通过spring获取到该bean对象，再通过反射将值set进去。</p>
<blockquote>
<p>参考：点评lion设计——com.dianping.lion.client.LionPlaceholderConfigurer</p>
</blockquote>
<h2 id="u81EA_u5B9A_u4E49spring_u6807_u7B7E"><a href="#u81EA_u5B9A_u4E49spring_u6807_u7B7E" class="headerlink" title="自定义spring标签"></a>自定义spring标签</h2><blockquote>
<p>官方给出的实现<br>Creating new XML configuration extensions can be done by following these (relatively) simple steps:</p>
<ol>
<li>Authoring an XML schema to describe your custom element(s).</li>
<li>Coding a custom NamespaceHandler implementation (this is an easy step, don’t worry).</li>
<li>Coding one or more BeanDefinitionParser implementations (this is where the real work is done).</li>
<li>Registering the above artifacts with Spring (this too is an easy step).</li>
</ol>
<p>具体参考：</p>
<ul>
<li><a href="http://blog.arganzheng.me/posts/custom-spring-xml-namespace.html" target="_blank" rel="external">《如何自定义Spring XML Bean配置》</a></li>
<li>pigeon中自定义标签的实现</li>
</ul>
</blockquote>
<h1 id="pigeon_u8BBE_u8BA1"><a href="#pigeon_u8BBE_u8BA1" class="headerlink" title="pigeon设计"></a>pigeon设计</h1><h2 id="pigeon_u5BA2_u6237_u7AEF_u5185_u90E8_u6A21_u5757_u7ED3_u6784"><a href="#pigeon_u5BA2_u6237_u7AEF_u5185_u90E8_u6A21_u5757_u7ED3_u6784" class="headerlink" title="pigeon客户端内部模块结构"></a>pigeon客户端内部模块结构</h2><p>如下图所示，pigeon各模块之间依赖抽象，而不依赖具体实现。如系统配置，依赖的是抽象的pigeon-config模块，而不是具体的pigeon-lion模块<br><img src="http://i12.tietuku.com/d5ff25c13ebc9b54.png" alt="pigeon客户端内部模块结构"></p>
<h2 id="zookeeper_u7684_u534F_u8BAE_u683C_u5F0F"><a href="#zookeeper_u7684_u534F_u8BAE_u683C_u5F0F" class="headerlink" title="zookeeper的协议格式"></a>zookeeper的协议格式</h2><p>每台机器的/data/webapps/config/appenv里会写上所处环境和zk地址，例如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">deployenv=qa</span><br><span class="line">zkserver=<span class="number">10.66</span><span class="number">.13</span><span class="number">.144</span>:<span class="number">2181</span>,<span class="number">10.66</span><span class="number">.11</span><span class="number">.251</span>:<span class="number">2181</span>,<span class="number">10.66</span><span class="number">.13</span><span class="number">.167</span>:<span class="number">2181</span>,<span class="number">10.66</span><span class="number">.32</span><span class="number">.77</span>:<span class="number">2181</span>,<span class="number">10.66</span><span class="number">.33</span><span class="number">.203</span>:<span class="number">2181</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>服务地址配置(ps：下文的+为字符串连接符，并非代表)：<ul>
<li>/DP/SERVER/  +  enscape(serviceName)，举例：/DP/SERVER/http:^^service.dianping.com^takeawayApiService^takeawayElemeActivityService_1.0.0，为了不让serviceName里的”/“让zookeeper误认为是节点，因此将”/“替换为”^”。</li>
<li>上述znode的值是服务ip加端口号，如192.168.8.120:4088</li>
</ul>
</li>
<li>服务权重配置<ul>
<li>/DP/WEIGHT/ip:port</li>
<li>值为1代表权重，如果为0代表这台机器暂时不提供服务，目前只有1和0两种值</li>
</ul>
</li>
<li>服务所属应用配置<ul>
<li>/DP/APP/ip:port</li>
<li>值为这个服务所属的应用名，这个应用名是读取本地classpath下META-INF/app.properties里的app.name值</li>
</ul>
</li>
</ul>
<h2 id="pigeon_u5BA2_u6237_u7AEF_u521D_u59CB_u5316"><a href="#pigeon_u5BA2_u6237_u7AEF_u521D_u59CB_u5316" class="headerlink" title="pigeon客户端初始化"></a>pigeon客户端初始化</h2><p>服务是通过spring的xml来配置，使用ProxyBeanFactory来定制实现一个类。</p>
<p>ProxyBeanFactory：实现了Spring的FactoryBean接口，用于在客户端建造Service类。通过getObject()返回动态代理后的类，初始化方法init()。</p>
<p>init()方法：</p>
<ol>
<li>用ClassLoader装载接口类</li>
<li>构造该Service对应的InvokerConfig</li>
<li>ServiceFactory调用ServiceProxy.getService(InvokerConfig)：<ul>
<li>触发ServiceFactory的静态初始化</li>
<li>调用ProviderBootStrap的init()</li>
</ul>
</li>
<li>ServiceProxy.getService(InvokerConfig)的内部流程:<br> a. 调用InvokerBootStrap的初始化：初始化客户端的相关资源<br> b. 通过DefaultSerializer（Serializer的默认实现）的proxyRequest()，构造一个动态代理请求的对象（ps：java的动态代理）。其业务逻辑是由ServiceInvocationProxy来实现<br> c. LoadBalanceManager注册服务对应的LoadBalance策略类<br> d. ClientManager初始化<pre><code>a) 启动线程池执行HeartBeatListener任务；
b) 启动线程池执行ReConnectListener任务；
c) ClusterListenerManager添加DefaultClusterListener，HeartBeatListener，ReConnectListener；
d) RegistryEventListener（或者称之为RegistryEventListenerManager表意更合适些）添加ClientManager.InnerServiceProviderChangeListener，ClientManager.InnerRegistryConnectionListener
</code></pre> e. ClientManager注册该service对应的所有client<pre><code>a) 先通过注册中心RegistryManager找到对应服务地址，即ip:port,ip:port
b) 再根据地址，找到对应的权重
c) 将上述已知信息存储到RegistryManager的map中
e) 根据上述connect（即ip:port）信息来决定构造netty还是http client，并将该client存储到DefaultClusterListener的map中，HeartBeatListener，ReConnectListener均持有该map的引用
</code></pre> f. 将InvokerConfig对应的动态代理的service存储到map中，InvokerConfig本身的hashcode是由其每个字段的值来确定的</li>
</ol>
<h2 id="InvokerBootStrap"><a href="#InvokerBootStrap" class="headerlink" title="InvokerBootStrap"></a>InvokerBootStrap</h2><p>stratup():</p>
<ol>
<li>用线程池执行服务调用超时检测的任务   </li>
<li>InvokerProcessHandlerFactory的初始化：<ul>
<li>采用了责任链设计模式</li>
<li>依次初始化了ClusterInvokeFilter，GatewayInvokeFilter，RemoteCallMonitorInvokeFilter，ContextPrepareInvokeFilter，RemoteCallInvokeFilter</li>
<li>构造了一个匿名的ServiceInvocationHandler，它本身包装了一个Filter，并拥有下一个filter的引用（下一个即filter的初始化顺序）</li>
<li>对外最终返回的产品是包装了ClusterInvokeFilter的匿名Handler</li>
</ul>
</li>
<li>初始化SerializerFactory：<ul>
<li>提供产品：Serializer</li>
</ul>
</li>
<li>使用ExtensionLoader加载Monitor对应的实现CatMonitor，并初始化</li>
</ol>
<h2 id="InvokerConfig"><a href="#InvokerConfig" class="headerlink" title="InvokerConfig"></a>InvokerConfig</h2><p>存储了服务接口类，服务名称，超时设置，调用方式，序列化方式等，相当于服务调用的配置</p>
<h2 id="RegistryManager"><a href="#RegistryManager" class="headerlink" title="RegistryManager"></a>RegistryManager</h2><p>Registry主要用于服务的注册和发现。RegistryManager类似一个策略管理类，Registry即是策略，不同的策略实现由ExtensionLoader来加载。RegistryManager包装了Registry的服务，并决定使用了哪个策略来实现服务并对外暴露。</p>
<h2 id="ExtensionLoader"><a href="#ExtensionLoader" class="headerlink" title="ExtensionLoader"></a>ExtensionLoader</h2><p>根据pigeon的理念，我定义一个抽象的接口，具体的实现就像插件一样可替换。所以在pigeon中，具体的配置模块、监控模块和注册模块等，都是如同可插拔的插件。ExtensionLoader就是来加载这些插件用。使用map来存储接口类对应的实现，若map中没有，则通过ServiceLoader来加载。</p>
<p>插件分为两种，一种可替换的，非此即彼；还有一种，是可以同时存在的，类似过滤器这种概念。</p>
<p>因此ExtensionLoader中的map有两种，一种是存的接口对应的实现（哪个实现在前面哪个被加载），一种存的是接口对应的实现list。</p>
<h2 id="SerializerFactory"><a href="#SerializerFactory" class="headerlink" title="SerializerFactory"></a>SerializerFactory</h2><ul>
<li>作用：根据序列化方式，返回对应的序列化类</li>
<li>工厂类</li>
<li>产品类接口Serializer:<ul>
<li>正反序列化客户端请求</li>
<li>正反序列化服务器端返回值</li>
<li>动态代理客户端请求</li>
</ul>
</li>
</ul>
<h2 id="ClusterListenerManager"><a href="#ClusterListenerManager" class="headerlink" title="ClusterListenerManager"></a>ClusterListenerManager</h2><p>管理了三种listener，DefaultClusterListener，HeartBeatListener，ReConnectListener。</p>
<p>对外暴露主要以下几个方法，addConnect(),removeConnect(),均为遍历listener实现</p>
<p>DefaultClusterListener的addConnect()：</p>
<ul>
<li>调用ClientSelector根据connect来决定到底是netty还是http client</li>
<li>将client存储到本地map中</li>
</ul>
<h2 id="ClientSelector"><a href="#ClientSelector" class="headerlink" title="ClientSelector"></a>ClientSelector</h2><p>抽象工厂模式：抽象工厂ClientFactory，两个实现类：HttpInvokerClientFactory，NettyClientFactory。产出的产品接口Client，分别两种产品HttpClient,NettyClient。</p>
<p>通过connect信息来决定到底使用哪个具体工厂</p>
<h2 id="Pigeon_u5BA2_u6237_u7AEF_u8BF7_u6C42_u8FC7_u7A0B"><a href="#Pigeon_u5BA2_u6237_u7AEF_u8BF7_u6C42_u8FC7_u7A0B" class="headerlink" title="Pigeon客户端请求过程"></a>Pigeon客户端请求过程</h2><p>ServiceInvocationProxy是实现了InvocationHandler(jdk) 的类，但其实际业务是由ServiceInvocationHandler——InvokerProcessHandlerFactory的产品来实现的。</p>
<h3 id="InvokerProcessHandlerFactory"><a href="#InvokerProcessHandlerFactory" class="headerlink" title="InvokerProcessHandlerFactory"></a>InvokerProcessHandlerFactory</h3><ul>
<li>产品是ServiceInvocationHandler</li>
<li>ServiceInvocationHandler包装了ServiceInvocationFilter</li>
<li>ServiceInvocationHandler采用了责任链的设计模式，指明了下一个处理的handler是哪个</li>
<li>责任链的顺序分别是ClusterInvokeFilter，GatewayInvokeFilter，RemoteCallMonitorInvokeFilter，ContextPrepareInvokeFilter，RemoteCallInvokeFilter</li>
</ul>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public interface ServiceInvocationHandler &#123;</span><br><span class="line"></span><br><span class="line">    /<span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line">     <span class="keyword">*</span> </span><br><span class="line">     <span class="keyword">*</span> </span><br><span class="line">     <span class="keyword">*</span> <span class="comment">@param invocationContext</span></span><br><span class="line">     <span class="keyword">*</span> <span class="comment">@return</span></span><br><span class="line">     <span class="keyword">*</span> <span class="comment">@throws Throwable</span></span><br><span class="line">     <span class="keyword">*</span>/</span><br><span class="line">    InvocationResponse handle(InvocationContext invocationContext) throws Throwable;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface ServiceInvocationFilter<span class="variable">&lt;I extends InvocationContext&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">    /<span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line">     <span class="keyword">*</span> </span><br><span class="line">     <span class="keyword">*</span> </span><br><span class="line">     <span class="keyword">*</span> <span class="comment">@param handler</span></span><br><span class="line">     <span class="keyword">*</span> <span class="comment">@param invocationContext</span></span><br><span class="line">     <span class="keyword">*</span> <span class="comment">@return</span></span><br><span class="line">     <span class="keyword">*</span> <span class="comment">@throws Throwable</span></span><br><span class="line">     <span class="keyword">*</span>/</span><br><span class="line">    InvocationResponse invoke(ServiceInvocationHandler handler, I invocationContext) throws Throwable;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ClusterInvokeFilter"><a href="#ClusterInvokeFilter" class="headerlink" title="ClusterInvokeFilter"></a>ClusterInvokeFilter</h3><p>pigeon客户端集群策略模式有4种，分别是：快速失败failfast/失败转移failover/失败忽略failsafe/并发取最快返回forking</p>
<blockquote>
<ul>
<li>failfast：调用服务的一个节点失败后抛出异常返回，可以同时配置重试timeoutRetry和retries属性</li>
<li>failover：调用服务的一个节点失败后会尝试调用另外的一个节点，可以同时配置重试timeoutRetry和retries属性</li>
<li>failsafe：调用服务的一个节点失败后不会抛出异常，返回null，后续版本会考虑按配置默认值返回</li>
<li>forking：同时调用服务的所有可用节点，返回调用最快的节点结果数据</li>
</ul>
</blockquote>
<p>根据服务的配置来使用某个cluster，一般是failfast。连接服务一般有两种，http请求走tomcat容器或者netty走tcp连接。获取到该服务下client的list，通过RouterManager(内部主要LoadBalanceManager来获取当前合适的client，<strong><em>如WeightedLoadBalance是将调用量按从小到大排序，返回调用量最小的</em></strong>)获取到当前合适的client，并将该client设到context中，以便在handler中传递。调用下一个handler，若抛出异常，则重试。</p>
<h3 id="GatewayInvokeFilter"><a href="#GatewayInvokeFilter" class="headerlink" title="GatewayInvokeFilter"></a>GatewayInvokeFilter</h3><p>调用InvokerStatisticsHolder的flowIn()，设置服务的app（即服务端项目的名称，配置在resources/META-INF/app.properties，服务端在注册服务到注册中心时，会将项目名称注册到zookeeper）对应的调用量，包括按天、按分、按秒的一些调用量统计。然后将请求传给下一个handler</p>
<p>上述调用量可以通过ip:4080/stats.json来查看。</p>
<h3 id="RemoteCallMonitorInvokeFilter"><a href="#RemoteCallMonitorInvokeFilter" class="headerlink" title="RemoteCallMonitorInvokeFilter"></a>RemoteCallMonitorInvokeFilter</h3><p>pigeon的监控打点，打出了请求的信息和配置，对当前秒、请求的大小（请求大小做了散列）打点</p>
<p>对cat的Transaction提取了接口，cat的Transaction只是其中一实现。保证了pigeon-remotting该包没有依赖cat的具体实现</p>
<h3 id="ContextPrepareInvokeFilter"><a href="#ContextPrepareInvokeFilter" class="headerlink" title="ContextPrepareInvokeFilter"></a>ContextPrepareInvokeFilter</h3><p>将InvocationContext中的参数抽取出来设置到InvocationRequest中去，将用户自定义的参数和pigeon内部自定义的参数传到InvocationRequest的RequestValues、GlobalValues中去。</p>
<blockquote>
<p>用户如何自定义参数：<br>1、简单的客户端A-&gt;服务端B的一级调用链路的参数传递<br>客户端：<br>String url = “<a href="http://service.dianping.com/com.dianping.pigeon.demo.EchoService" target="_blank" rel="external">http://service.dianping.com/com.dianping.pigeon.demo.EchoService</a>“;<br>EchoService service = ServiceFactory.getService(url, EchoService.class);<br>…<br>ContextUtils.putRequestContext(“key1”, “1”);<br>System.out.println(“service result:” + service.echo(input));<br>服务端：<br>public String echo(String input) {<br>System.out.println(ContextUtils.getLocalContext(“key1”));<br>return “echo:” + input;<br>}<br>2、服务端B-&gt;客户端A的参数传回<br>服务端：<br>ContextUtils.putResponseContext(“key1”, “1”);<br>客户端：<br>ContextUtils.getResponseContext(“key1”);<br>3、全链路传递<br>如果需要在全链路传递对象，如A-&gt;B-&gt;C-&gt;D，需要使用以下接口：<br>在A发送请求端：ContextUtils.putGlobalContext(“key1”, “1”);<br>在D接收请求端：ContextUtils.getGlobalContext(“key1”);</p>
</blockquote>
<h3 id="RemoteCallInvokeFilter"><a href="#RemoteCallInvokeFilter" class="headerlink" title="RemoteCallInvokeFilter"></a>RemoteCallInvokeFilter</h3><p>实际网络调用发生的地方，<strong>在调用前后都有调beforeInvoke()和afterInvoke()，用户自定义的拦截器就是在这两个方法中被调用的</strong></p>
<p>从代码中可以看到，一共有三种timeout，分别是：服务的timeout、方法的timeout和ThreadLocal的timeout，其优先级也是依次递增。不过方法的timeout配置并没有开放出来，我们有很多服务，其不同的方法超时是不一样的，客户端配服务的timeout时被最短的模板决定了。</p>
<p><em>从服务设计的角度来讲，不同重要性、服务响应时间的方法不应该放在一个服务中，但是pigeon给我们提供了对方法级别线程池的配置，以及自动的服务隔离措施，从这点上讲，pigeon保证了我们在代码设计时无需考虑这些额外因素，因为它把这些因素都引到了xml配置上。</em></p>
<p>通过client调用请求，会先调用AbstractClient的实现：</p>
<ul>
<li>将对应服务地址（ip:port）的调用量记下来，其每次加的调用量为1.0f/weight，这个调用量会影响到loadBalance</li>
<li>调NettyClient的doWrite()实现：</li>
</ul>
<h4 id="NettyClient"><a href="#NettyClient" class="headerlink" title="NettyClient"></a>NettyClient</h4><p>使用的netty3，设置的pipeline：InvokerDecoder、NettyClientHandler、InvokerEncoder</p>
<p>InvokerEncoder：</p>
<ul>
<li>消息头固定7个字节：<ul>
<li>第1-3个字节固定为：57，58，2，其中57和58写死的，但2是指序列化的方式，hessian为2</li>
<li>第4-7个字节：消息体长度，int，占4个字节，值为消息体长度（hessian序列化字节长度）</li>
</ul>
</li>
<li><p>消息体，从第8个字节开始：hessian序列化字节，对象类型为DefaultRequest和DefaultResponse</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class DefaultRequest implements InvocationRequest &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">byte</span> serialize;<span class="comment">//必填，序列化类型，hessian为2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> seq;<span class="comment">//必填，消息sequence，long型，值请从0开始递增，每个消息的sequence都不同</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> callType = <span class="number">1</span>;<span class="comment">//必填，如果调用需要返回结果，固定为1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> timeout = <span class="number">0</span>;<span class="comment">//必填，超时时间，单位毫秒</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> serviceName;<span class="comment">//必填，服务名称url，服务唯一的标识</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> methodName;<span class="comment">//必填，服务方法名称</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">Object</span>[] parameters;<span class="comment">//必填，服务方法的参数值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> messageType = <span class="number">2</span>;<span class="comment">//必填，消息类型，服务调用固定为2，心跳为1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">Object</span> context;<span class="comment">//老的avatar-tracker上下文传递内容，如果要传递对象，需设置</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> app = <span class="string">""</span>;<span class="comment">//必填，调用者所属应用名称，在META-INF/app.properties里的app.name值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;<span class="keyword">String</span>, Serializable&gt; globalValues = <span class="keyword">null</span>;<span class="comment">//用于新的全局上下文传递，可不填</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;<span class="keyword">String</span>, Serializable&gt; requestValues = <span class="keyword">null</span>;<span class="comment">//用于新的上下文传递，可不填</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> class DefaultResponse implements InvocationResponse &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> seq;<span class="comment">//返回的消息sequence，对应发送的消息sequence，long型</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> messageType;<span class="comment">//消息类型，服务调用为2，服务调用业务异常为4，服务框架异常为3，心跳为1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">Object</span> returnVal;<span class="comment">//返回服务调用结果，如果是异常，返回类型为</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">Object</span> context;<span class="comment">//老的avatar-tracker上下文传递内容</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;<span class="keyword">String</span>, Serializable&gt; responseValues = <span class="keyword">null</span>;<span class="comment">//用于新的上下文传递返回的结果</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>消息尾：固定11个字节</p>
<ul>
<li>前8个字节为消息sequence，long型，值请从0开始递增，每个消息的sequence都不同；</li>
<li>后3个字节固定为：29，30，31</li>
</ul>
</li>
</ul>
<p>doWrite()：调用Channel的write()，若抛出异常，则返回默认返回值</p>
<p>NettyClientHandler：获取服务端的返回值，交付NettyClient处理</p>
<p>NettyClient处理Response，会将Response里的sequence来和之前的请求对应上<br>处理Response用了有界线程池，corePoolSize 10，maxPoolSize 100，队列大小 800</p>
<p>下述代码是同步调用的，调用请求时将CallbackFuture和调用请求关联起来，请求发出去后，future处于blocking状态，直到被notify<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Constants.CALL_SYNC.equalsIgnoreCase(callType)) &#123;</span><br><span class="line">    CallbackFuture future = <span class="keyword">new</span> CallbackFuture();</span><br><span class="line">    response = InvokerUtils.sendRequest(client, invocationContext.getRequest(), future);</span><br><span class="line">    <span class="keyword">if</span> (response == <span class="keyword">null</span>) &#123;</span><br><span class="line">        response = future.get(timeout);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> CallbackFuture <span class="keyword">implements</span> Callback, CallFuture &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> done = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> run() &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.done = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.response.getMessageType() == Constants.MESSAGE_TYPE_SERVICE) &#123;</span><br><span class="line">                <span class="keyword">this</span>.success = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> InvocationResponse get(<span class="keyword">long</span> timeoutMillis) <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">//判断有没有超时，若没有超时，则wait</span></span><br><span class="line">            <span class="keyword">long</span> start = request.getCreateMillisTime();</span><br><span class="line">            <span class="keyword">while</span> (!<span class="keyword">this</span>.done) &#123;</span><br><span class="line">                <span class="keyword">long</span> timeoutMillis_ = timeoutMillis - (System.currentTimeMillis() - start);</span><br><span class="line">                <span class="keyword">if</span> (timeoutMillis_ &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">                    sb.<span class="keyword">append</span>(<span class="string">"request timeout, current time:"</span>).<span class="keyword">append</span>(System.currentTimeMillis())</span><br><span class="line">                            .<span class="keyword">append</span>(<span class="string">"\r\nrequest:"</span>).<span class="keyword">append</span>(request).<span class="keyword">append</span>(<span class="string">"\r\nhost:"</span>).<span class="keyword">append</span>(client.getHost())</span><br><span class="line">                            .<span class="keyword">append</span>(<span class="string">":"</span>).<span class="keyword">append</span>(client.getPort());</span><br><span class="line">                    ServiceStatisticsHolder.flowOut(request, client.getAddress());</span><br><span class="line">                    NetTimeoutException e = <span class="keyword">new</span> NetTimeoutException(sb.toString());</span><br><span class="line">                    <span class="keyword">throw</span> e;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.wait(timeoutMillis_);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            processContext();<span class="comment">//处理从服务器端传过来的自定义参数</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (response.getMessageType() == Constants.MESSAGE_TYPE_EXCEPTION) &#123;</span><br><span class="line">                RpcException cause = InvokerUtils.toRpcException(response);</span><br><span class="line">                StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">                sb.<span class="keyword">append</span>(<span class="string">"remote call exception\r\nrequest:"</span>).<span class="keyword">append</span>(request).<span class="keyword">append</span>(<span class="string">"\r\nhost:"</span>)</span><br><span class="line">                        .<span class="keyword">append</span>(client.getHost()).<span class="keyword">append</span>(<span class="string">":"</span>).<span class="keyword">append</span>(client.getPort()).<span class="keyword">append</span>(<span class="string">"\r\nresponse:"</span>)</span><br><span class="line">                        .<span class="keyword">append</span>(response);</span><br><span class="line">                logger.error(sb.toString(), cause);</span><br><span class="line">                monitor.logError(sb.toString(), cause);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (response.getMessageType() == Constants.MESSAGE_TYPE_SERVICE_EXCEPTION) &#123;</span><br><span class="line">                <span class="keyword">if</span> (Constants.INVOKER_LOG_APP_EXCEPTION) &#123;</span><br><span class="line">                    Throwable cause = InvokerUtils.toApplicationException(response);</span><br><span class="line">                    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">                    sb.<span class="keyword">append</span>(<span class="string">"remote service exception\r\nrequest:"</span>).<span class="keyword">append</span>(request).<span class="keyword">append</span>(<span class="string">"\r\nhost:"</span>)</span><br><span class="line">                            .<span class="keyword">append</span>(client.getHost()).<span class="keyword">append</span>(<span class="string">":"</span>).<span class="keyword">append</span>(client.getPort()).<span class="keyword">append</span>(<span class="string">"\r\nresponse:"</span>)</span><br><span class="line">                            .<span class="keyword">append</span>(response);</span><br><span class="line">                    logger.error(sb.toString(), cause);</span><br><span class="line">                    monitor.logError(sb.toString(), cause);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.response;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="InvokerHelper"><a href="#InvokerHelper" class="headerlink" title="InvokerHelper"></a>InvokerHelper</h3><p>这是一个很重要的类，主要是用ThreadLocal存储本次请求的timeout，服务地址以及callback(回调)。优先级最高，即高于spring中的配置。可以用来hack做一些事情，<strong>不推荐线上使用，主要用于测试</strong>。</p>
<h2 id="Pigeon_u540E_u53F0_u7EBF_u7A0B"><a href="#Pigeon_u540E_u53F0_u7EBF_u7A0B" class="headerlink" title="Pigeon后台线程"></a>Pigeon后台线程</h2><h3 id="u5FC3_u8DF3"><a href="#u5FC3_u8DF3" class="headerlink" title="心跳"></a>心跳</h3><p>目的是保持客户端与可用的服务端之间的连接，客户端发起，服务端响应，1.5s超时，每3s发送一次，连续5次不成功则考虑摘除该服务端，是否摘除是判断服务端有20%以上的节点可用就可以摘除该不用的节点，摘除后会放入重连线程</p>
<h3 id="u91CD_u8FDE"><a href="#u91CD_u8FDE" class="headerlink" title="重连"></a>重连</h3><p>目的是检测不可用的服务端，如果连续5次检测成功则恢复该服务端的调用</p>
<h3 id="u7EDF_u8BA1"><a href="#u7EDF_u8BA1" class="headerlink" title="统计"></a>统计</h3><h1 id="Pigeon_u670D_u52A1_u7AEF"><a href="#Pigeon_u670D_u52A1_u7AEF" class="headerlink" title="Pigeon服务端"></a>Pigeon服务端</h1><h2 id="pigeon_u81EA_u5B9A_u4E49_u670D_u52A1_u6807_u7B7E"><a href="#pigeon_u81EA_u5B9A_u4E49_u670D_u52A1_u6807_u7B7E" class="headerlink" title="pigeon自定义服务标签"></a>pigeon自定义服务标签</h2><p>定义了schema验证文件，在pigeon-remotting项目的classpath下定义了pigeon-service-2.0.xsd</p>
<p>实现了CommonNamespaceHandler，其实现了NamespaceHandlerSupport（spring对NamespaceHandler的实现，通过它，我们只需要注册BeanDefinitionParser对象即可）</p>
<p>定义了pigeon:server、pieon-service标签，由ServerBeanDefinitionParser和ServiceBeanDefinitionParser来负责解析对应的xml标签的。这两个类均实现了BeanDefinitionParser接口</p>
<p>为了让spring加载xml时能够去加载我们的NamespaceHandler类和xsd schema文件，还需要两个配置文件</p>
<ul>
<li>pigeon-config中配置的 META-INF/spring.handlers<br>http\://code.dianping.com/schema/pigeon=com.dianping.pigeon.config.spring.CommonNamespaceHandler</li>
<li>pigeon-remotting中配置的  META-INF/spring.schemas<br>http\://code.dianping.com/schema/pigeon/pigeon-service-2.0.xsd=com/dianping/pigeon/remoting/config/spring/pigeon-service-2.0.xsd</li>
</ul>
<p>偶然发现还有pigeon-extension-2.0.xsd，猜测可能是开放出标签让用户选择使用哪个插件，比如配置选择是用zookeeper还是本地文件配置还是自定义的配置类。目前对于多个插件，如果是只能用一个的话，默认选配在第一个的标签。然并卵，相应的parser类还没有开发出来。</p>
<p>最终我们在使用自定义标签时，需要在beans里面加入我们上面配置的namespace，如下：<br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans xmlns=<span class="string">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">    xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> xmlns:context=<span class="string">"http://www.springframework.org/schema/context"</span></span><br><span class="line">    xmlns:tx=<span class="string">"http://www.springframework.org/schema/tx"</span> xmlns:pigeon=<span class="string">"http://code.dianping.com/schema/pigeon"</span></span><br><span class="line">    xsi:schemaLocation=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd</span></span><br><span class="line">    http:<span class="comment">//www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd</span></span><br><span class="line">    http:<span class="comment">//www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd</span></span><br><span class="line">                  http:<span class="comment">//code.dianping.com/schema/pigeon http://code.dianping.com/schema/pigeon/pigeon-service-2.0.xsd"&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>xmlns 默认命名空间<br>xmlns:xsi 声明XML Schema实例的名称空间，，并将xsi前缀与该名称空间绑定，这样模式处理器就可以识别xsi:schemaLocation属性。XML Schema实例名称空间的前缀通常使用xsi。<br>使用xsi:schemaLocation属性指定名称空间和对应的schema文件<br>xmlns:pigeon是将pigeon作为<a href="http://code.dianping.com/schema/pigeon的别名" target="_blank" rel="external">http://code.dianping.com/schema/pigeon的别名</a></p>
<p>pigeon的parser类在碰到value的前缀是${、后缀是}时，会把它作为lion值去lion读取，然而并没有动态更新，<strong>也就是说一但配置，lion值改了是没法更新配置的</strong></p>
<h2 id="Pigeon_u670D_u52A1_u7AEF_u521D_u59CB_u5316"><a href="#Pigeon_u670D_u52A1_u7AEF_u521D_u59CB_u5316" class="headerlink" title="Pigeon服务端初始化"></a>Pigeon服务端初始化</h2><p>pigeon初始化服务有三种方式：</p>
<ol>
<li>xml配置，通过ServiceRegistry注册服务，服务的属性都是默认的</li>
<li>xml配置，通过<pigeon:server>和<pigeon:service>来注册服务，并可以配置服务的属性</pigeon:service></pigeon:server></li>
<li>通过注解来注入service和引用service</li>
</ol>
<p>服务端的配置分为两方面：服务和服务器的<br>服务的包括：url,version,useSharedPool<br>服务器的包括：corePoolSize,port,maxPoolSize,workQueueSize</p>
<p>当我们用方法1配置时，只能简单的将服务key和服务对象关联起来，服务和服务器的配置都是默认的：port:4080,corePoolSize:60,maxPoolSize:500,workQueueSize:1000,useSharedPool:true。使用方法2和3配置，均可以配置服务的属性，若不配置，则默认值同上。</p>
<p>方法2是通过自定义spring服务标签来实现的，上面一个章节已经阐述过实现。主要是通过RootBeanDifinition(spring对bean的包装)、ManagedList(spring对集合的包装)来实现的，通过BeanDefinitionRegistry来注入bean。pigeon:server标签解析出来的类是ServerBean，pigeon:service标签解析出来的类是SingleServiceBean，注入spring时指明了初始化方法init()。它的初始化和ServiceRegistry很相似，不同的是它多了对方法的配置。</p>
<p>方法3也定义了服务标签pigeon:annotation，主要是让用户来配置扫描哪些包下面的类，将配置了@Service标签的类载入管理，将配了@Reference的注入相应的服务类</p>
<h3 id="u670D_u52A1_u521D_u59CB_u5316_u8FC7_u7A0B"><a href="#u670D_u52A1_u521D_u59CB_u5316_u8FC7_u7A0B" class="headerlink" title="服务初始化过程"></a>服务初始化过程</h3><ul>
<li>将服务的配置属性装配到ProviderConfig类中，每一个服务对应一个ProviderConfig</li>
<li>将服务key和ProviderConfig关联起来，存储到map里</li>
<li>如果service实现了InitializingService，则调用该初始化方法。<strong>功效有点类似spring的postConstruct()，但如果我们使用pigeon的注解，那么无疑通过实现该接口来初始化是比较好的选择。</strong></li>
<li>将服务key和服务下面的Method关联起来，放到map里（ps：过滤了Object类和Class类的方法，过滤Class类方法比较奇怪）</li>
<li>在NettyServer中管理服务key对应的线程池以及服务方法key（服务key-methodname）对应的线程池。<ul>
<li>如果服务配置了线程池，且没有配置方法，则该服务key会有一个对应的线程池</li>
<li>如果配了方法，则服务方法key会有一个对应的线程池。方法用户在配置时只能配置最大线程数量，corePoolSize是最大/3</li>
<li>如果服务配置了线程池，配了部分方法的，那么该方法会走Server的共享线程池</li>
</ul>
</li>
<li>如果Server没有启动，则启动，同时启动线程检测请求处理是否超时，若超时记录次数，并中断</li>
<li>通过反射获取service提供的方法，除去了Object自带的方法</li>
<li>ProviderBootStrap初始化</li>
<li>启动NettyServer</li>
<li>发布管理的服务到注册中心</li>
</ul>
<h3 id="ProviderBootStrap"><a href="#ProviderBootStrap" class="headerlink" title="ProviderBootStrap"></a>ProviderBootStrap</h3><p>init():</p>
<ol>
<li>使用ExtensionLoader加载ConfigManager对应的实现LionConfigManager；</li>
<li>初始化ProviderProcessHandlerFactory：<ul>
<li>提供产品：ServiceInvocationHandler</li>
</ul>
</li>
<li>初始化SerializerFactory：<ul>
<li>提供产品：Serializer</li>
</ul>
</li>
<li>使用ExtensionLoader加载Monitor对应的实现CatMonitor，并初始化</li>
<li>启动一守护线程，用于jvm关闭时，销毁资源</li>
<li>初始化RegistryManager（注册中心）</li>
<li>初始化JettyServer，并启动</li>
</ol>
<h2 id="u670D_u52A1_u8BF7_u6C42_u8D85_u65F6_u8BBE_u8BA1"><a href="#u670D_u52A1_u8BF7_u6C42_u8D85_u65F6_u8BBE_u8BA1" class="headerlink" title="服务请求超时设计"></a>服务请求超时设计</h2><p>处理客户端请求是通过线程池执行的，任务提交到线程池会返回一个Future，这个future传递给了RequestTimeoutListener，这个listener睡眠5s后遍历当前在处理的请求，将超过时间的，通过future来cancel</p>
<h2 id="Pigeon_u670D_u52A1_u7AEF_u8BF7_u6C42_u8FC7_u7A0B"><a href="#Pigeon_u670D_u52A1_u7AEF_u8BF7_u6C42_u8FC7_u7A0B" class="headerlink" title="Pigeon服务端请求过程"></a>Pigeon服务端请求过程</h2><p>在客户端通过netty把请求发过来时，先挑选该请求或方法对应的线程池，将调用service处理请求的任务提交到线程池执行。</p>
<p>选择请求的线程池的方法如下：<br><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ThreadPool selectThreadPool(final InvocationRequest <span class="built_in">request</span>) &#123;</span><br><span class="line">    ThreadPool pool = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (!CollectionUtils.<span class="built_in">isEmpty</span>(methodThreadPools)) &#123;</span><br><span class="line">        pool = methodThreadPools.<span class="keyword">get</span>(<span class="built_in">request</span>.getServiceName() + <span class="string">"#"</span> + <span class="built_in">request</span>.getMethodName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!CollectionUtils.<span class="built_in">isEmpty</span>(serviceThreadPools)) &#123;</span><br><span class="line">        pool = serviceThreadPools.<span class="keyword">get</span>(<span class="built_in">request</span>.getServiceName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pool == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (enableSlowPool &amp;&amp; requestTimeoutListener.isSlowRequest(<span class="built_in">request</span>)) &#123;</span><br><span class="line">            pool = slowRequestProcessThreadPool;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"server"</span>.equals(poolStrategy)) &#123;</span><br><span class="line">                pool = requestProcessThreadPool;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pool = sharedRequestProcessThreadPool;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return pool;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>处理请求的过程和客户端相似，也是一个责任链处理请求的模式。一共有以下filter（handler包裹filter）：MonitorProcessFilter,WriteResponseProcessFilter,ContextTransferProcessFilter,ExceptionProcessFilter,GatewayProcessFilter,BusinessProcessFilter</p>
<p>MonitorProcessFilter: cat打点，并将请求和返回的数据打进去，清除ThreadLocal的数据</p>
<p>WriteResponseProcessFilter:将返回写入到channel，并调用用户注册的拦截器做返回后的处理</p>
<p>ContextTransferProcessFilter:将请求里面带过来的额外参数，即自定义参数放入ThreadLocal。</p>
<p>ExceptionProcessFilter:包装服务调用抛出的异常</p>
<p>GatewayProcessFilter:对客户端应用做服务限流，比如配置pigeon.provider.applimit=takeaway-mapi:10000</p>
<p>BusinessProcessFilter:调用用户注册的拦截器做返回前的处理，将请求里服务的方法和服务提供的方法作匹配，返回匹配度最高的那个方法<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">private <span class="type">int</span> matching(<span class="type">ServiceMethod</span> <span class="keyword">method</span>, <span class="type">String</span>[] paramClassNames, boolean <span class="keyword">cast</span>)</span><br><span class="line">            throws <span class="type">InvocationFailureException</span> &#123;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; paramClassNames.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (paramClassNames[i].equals(<span class="type">Constants</span>.<span class="type">TRANSFER_NULL</span>)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Class</span>&lt;?&gt; paramClass = null;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            paramClass = <span class="type">ClassUtils</span>.loadClass(paramClassNames[i]);</span><br><span class="line">        &#125; catch (<span class="type">ClassNotFoundException</span> e) &#123;</span><br><span class="line">            throw new <span class="type">InvocationFailureException</span>(<span class="string">"no class found for parameter:"</span> + paramClassNames[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (paramClass == <span class="keyword">method</span>.getParameterClasses()[i]) &#123;</span><br><span class="line">            k++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">cast</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (paramClassNames[i].equals(<span class="type">Double</span>.class.getName())) &#123;</span><br><span class="line">                paramClass = <span class="type">Float</span>.class;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (paramClassNames[i].equals(<span class="type">Integer</span>.class.getName())) &#123;</span><br><span class="line">                paramClass = <span class="type">Short</span>.class;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">if</span> (paramClass == <span class="keyword">method</span>.getParameterClasses()[i]) &#123;</span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">method</span>.getParameterClasses()[i].isAssignableFrom(paramClass)) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="pigeon_u5982_u4F55_u63D0_u4F9Bhttp_u5F62_u5F0F_u7684_u670D_u52A1_u8C03_u7528"><a href="#pigeon_u5982_u4F55_u63D0_u4F9Bhttp_u5F62_u5F0F_u7684_u670D_u52A1_u8C03_u7528" class="headerlink" title="pigeon如何提供http形式的服务调用"></a>pigeon如何提供http形式的服务调用</h2><p>pigeon除了启动nettyserver，默认还启动JettyServer，绑定了一个DispatcherServlet,根据http请求中参数明确的服务和方法以及序列化方式来给服务的返回值，默认的请求需要按照架构的规范来表明一些参数，你也可以自定义HttpAdapter，来自定义请求参数</p>
<p>总结:</p>
<ul>
<li>初始化最好加一个全局变量来控制，防止初始化函数被误调用</li>
</ul>
<p>依次初始化正常业务请求、心跳、健康监测的ServiceInvocationFilter和ServiceInvocationHandler；  </p>
<p>有些监听修改的listener，是放在一些类中，而不是这个类实现了监听修改</p>
<p>weight 控制了预热   0是怎么弄的</p>
<p>pigeon代码很多写的也比较有问题  前后不一致  设计了后没有按设计去实现</p>
<p>pigeon三种配置文件<br>config/applicationContext.properties<br>config/pigeon.properties<br>/data/webapps/config/pigeon.properties<br>优先级越来越高<br>针对测试环境，自动注册服务的问题，建议每人修改本地文件/data/webapps/config/pigeon.properties，将自动注册关闭</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/pigeon/">pigeon</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>








  
    <article id="post-学习资源" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/02/03/学习资源/" class="article-date">
      <time datetime="2016-02-03T08:43:42.000Z" itemprop="datePublished">2016-02-03</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/02/03/学习资源/">学习资源</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p><a href="http://m.open-open.com/m/news/view/62b369" target="_blank" rel="external">java工程师成神之路</a><br><a href="http://www.open-open.com/lib/view/open1390916852007.html" target="_blank" rel="external">JVM性能调优监控工具</a>，该网站下还有很多其他资源</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>








  
    <article id="post-hessian序列化bug分析" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/02/03/hessian序列化bug分析/" class="article-date">
      <time datetime="2016-02-03T03:52:16.000Z" itemprop="datePublished">2016-02-03</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/02/03/hessian序列化bug分析/">hessian序列化bug分析</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <blockquote>
<p>跟hessian的Ref机制有关，对于Timestamp对象，解析器和反解析器在Ref上有不一致的地方导致。</p>
</blockquote>
<h2 id="hessian_u5E8F_u5217_u5316_u6574_u4F53_u5206_u6790"><a href="#hessian_u5E8F_u5217_u5316_u6574_u4F53_u5206_u6790" class="headerlink" title="hessian序列化整体分析"></a>hessian序列化整体分析</h2><p><img src="http://i13.tietuku.com/9ca5080bf9e749c5.png" alt="序列化器类图"></p>
<blockquote>
<p>SerializeFactory来管理这些序列化类，它们都是AbstractSerializer的子类，实现共同的接口void writeObject(Object obj, AbstractHessianOutput out)​；工厂根据对象类型来创建不同的序列化类，BasicSerializer是针对基本类型包括包装类型，JavaSerializer是自定义对象类型，SqlDateSerializer则是针对java.sql.Date​、java.sql.Time、java.sql.Timestamp类型的，其他的都是顾名思义。这里有一个关键点，那就是java.util.Date类型的是放在BasicSerializer中的.</p>
</blockquote>
<h2 id="u5E8F_u5217_u5316_u5FEB_u7684_u673A_u5236-Ref"><a href="#u5E8F_u5217_u5316_u5FEB_u7684_u673A_u5236-Ref" class="headerlink" title="序列化快的机制-Ref"></a>序列化快的机制-Ref</h2><p>Hessian序列化很快的一个原因是Ref机制，这里我们对它详细地描述下。我们会发现大多数序列化类开始之前都有这样一段代码：<br><img src="http://i13.tietuku.com/f115f76b2dc8d8a4.png" alt=""><br>这段代码的主要作用就是如果map里有与该对象内存地址相同的，我们就不序列化该对象本身，只序列化它的引用。具体如下：<br><img src="http://i13.tietuku.com/e59df7cb657b9572.png" alt=""></p>
<blockquote>
<p>_refs是hessian实现的一个类似hashmap的数据结构，有自己的散列和rehash。key是被序列化对象，value是加入时<code>_refs</code>的的大小。get是通过判断内存地址来比较的。如果找到一样的，就序列化它的引用，这是序列化流里会有个标识为r以及加入_refs时的顺序ref，如果找不到，就把它放到这个map里。<br>反序列化时，读取map，遍历，对key和value分别反解析并放到map中，中间采用了大量的递归调用。本地维护了一个ArrayList ：<code>_refs</code>（同名不同的数据结构），每一个对象在被反解析时（基本、包装类型除外），会将自己本身加入到该list中。读到对象类型为r时，会从<code>_refs</code>里直接获取该对象，get(index)，index为序列化时写入的ref，直接将字段set为获取的对象。<br>hessian并没有在序列化时将<code>_refs</code>表通过网络传过去，而是通过同样的解析和反解析顺序，保证了两边从<code>_refs</code>里获取对象的一致性。那么，它就要保证添加Ref和读取Ref的逻辑是一致的，如果不一致就会出现类型不一致的异常。</p>
</blockquote>
<h2 id="u5E8F_u5217_u5316bug_u539F_u56E0_u5206_u6790"><a href="#u5E8F_u5217_u5316bug_u539F_u56E0_u5206_u6790" class="headerlink" title="序列化bug原因分析"></a>序列化bug原因分析</h2><blockquote>
<p>那么我们的service为什么会出错呢？因为hessian在序列化时Timestamp是走的SqlDateSerializer，这个序列化器是会加入到_refs这个map里的，但是读取的时候，Timestamp却不会加入到客户端里地_refs表里。这时候我们两端_refs就不一致了。而phoneList在数据库phone字段为空时都会赋为ArrayUtils.EMPTY_STRING_ARRAY，它是一个final static对象。String[]是会写_refs表的，如果有第二个String[]跟第一个相等，那么它会被标记为引用类型并记下加入表时的顺序。这时候反序列化的时候timestamp是不会加入_refs的，反序列化出来String[]的ref(即list中的index)就有偏差了。java.util.Date是被视为基础类型的，服务和客户端都不会写入_refs表。</p>
</blockquote>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/中间件/">中间件</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hessian/">hessian</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>








  
    <article id="post-我的博客搭建历程" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/02/02/我的博客搭建历程/" class="article-date">
      <time datetime="2016-02-02T10:12:38.000Z" itemprop="datePublished">2016-02-02</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/02/02/我的博客搭建历程/">我的博客搭建历程</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <blockquote>
<p>搭建的细则就不冗述了，就主要环节描述下</p>
</blockquote>
<h3 id="github__26amp_3B_git"><a href="#github__26amp_3B_git" class="headerlink" title="github &amp; git"></a>github &amp; git</h3><ul>
<li>账号</li>
<li>ssh key</li>
<li>git  </li>
</ul>
<h3 id="hexo"><a href="#hexo" class="headerlink" title="hexo"></a>hexo</h3><ul>
<li>安装</li>
<li>美化：<blockquote>
<p>使用主题，推荐Yelee，链接<a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" rel="external">https://github.com/MOxFIVE/hexo-theme-yelee</a><br>修改Yelee的配置，路径是themes/yelee/_config.yml，具体可修改的配置看其内容</p>
</blockquote>
</li>
</ul>
<h3 id="u5199_u535A_u6587_u4F7F_u7528_u7684_u5DE5_u5177"><a href="#u5199_u535A_u6587_u4F7F_u7528_u7684_u5DE5_u5177" class="headerlink" title="写博文使用的工具"></a>写博文使用的工具</h3><ul>
<li>图片：一个chrome插件”极简图床”，自动将图片传到你的七牛云存储账号，并生产分享链接和MarkDown语法</li>
<li>MarkDown语法</li>
<li>Sublime Text3，编辑博文用，需要启用Package Control，并安装插件，我使用的MarkdownEditor</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/博客/">博客</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/博客/">博客</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>








  
    <article id="post-cpu使用率过高" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/02/02/cpu使用率过高/" class="article-date">
      <time datetime="2016-02-02T02:15:18.000Z" itemprop="datePublished">2016-02-02</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/02/02/cpu使用率过高/">cpu使用率过高</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <blockquote>
<p>文章转载自内网，挺不错的，分享下<br>程序有时会出现CPU使用率过高的情况，以下是对jvm线程的一次排查。<br>首先，top命令看一下情况，是否为java的进程导致的CPU使用率过高，CPU使用率理论上不应该超过CPU核数＊100%。</p>
</blockquote>
<h1 id="u6392_u67E5_u6B65_u9AA4"><a href="#u6392_u67E5_u6B65_u9AA4" class="headerlink" title="排查步骤"></a>排查步骤</h1><h2 id="u6B65_u9AA4_u4E00"><a href="#u6B65_u9AA4_u4E00" class="headerlink" title="步骤一"></a>步骤一</h2><p>命令<br>    <code>top</code><br><img src="http://i4.tietuku.com/ac5ce6bc242a649a.png" alt=""></p>
<h2 id="u6B65_u9AA4_u4E8C"><a href="#u6B65_u9AA4_u4E8C" class="headerlink" title="步骤二"></a>步骤二</h2><p>继续使用top命令，但这次是看这个进程包含的线程cpu使用情况<br>命令：<br>    <code>top -Hp 29605 -d 1 -n3</code><br><img src="http://i4.tietuku.com/671357c2d1095854.png" alt=""></p>
<h2 id="u6B65_u9AA4_u4E09"><a href="#u6B65_u9AA4_u4E09" class="headerlink" title="步骤三"></a>步骤三</h2><p>图中的nid，是根据第二步的top中的PID转换为16进制后，查到的。<br>命令：<br>    <code>jstack -l 29605|grep -A 20 &quot;74d8&quot;</code><br><img src="http://i4.tietuku.com/95b81534c010e361.png" alt=""></p>
<p>到此基本定位了问题，接下来是分析代码看如何解决了</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/故障排查/">故障排查</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpu使用率/">cpu使用率</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>








  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                &copy; 2016 SaMichael
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的静态博客框架">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减双栏 Hexo 博客主题">Yelee</a> by MOxFIVE
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" >本站到访数: 
                            <span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>, </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit">本页阅读量: 
                            <span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 6;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>




<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>

<script>
    $(document).ready(function() {
        if ($("#comments").length < 1) {
            $("#scroll > a:nth-child(2)").hide();
        };
    })
</script>


<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>